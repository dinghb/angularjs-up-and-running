# 指令的scope

## 默认scope 

默认情况下，每一条指令都继承了它的父作用域(也就是传入link函数的scope参数)，且指令的作用域与父元素的作用域保持一致，也就是说: 
* 指令能够访问父作用域中所有定义的变量和函数
* 任何对指令作用域的修改会立即影响到父作用域。

这样导致的问题： 
* 该作用域中添加的变量/函数 也会影响到父作用域。
* 父作用域中也会突然出现一些变量和函数
* 指令可以会无意间覆盖了父作用域中已有的同名函数/变量
* 指令也可能无意间用到了父作用域中的函数/变量

## scope参数 

AngularJs在定义指令时，有一个scope参数：
```javascript
// File: chapter11/directive-with-scope/directive.js
angular.module('stockMarketApp')
  .directive('stockWidget', [function() {
    return {
      restrict: 'A',
      scope: {
        stockData: '='
      }
    };
  }]);
``` 
scope参数可以接受：
* false: 默认值，指令的作用域与父作用域一致，即指令和包含指令的父元素是处在同一个作用域下的。
* true: 指令的作用域继承与父作用域，不过指令会创建自己的作用域（或叫做副本？）。即可以用父作用域的变量和函数，但是在指令中对这些变量和元素进行修改不会父作用域产生影响。
* object: 创建一个隔离作用域（isolated scope），这个作用域不继承父作用域的任何信息，此时父作用域的数据信息的要传递给指令（单向），需要通过指令在隔离作用域中对外暴露的相应接口。

其实，从设计和使用的角度来说，上面的设计很好理解。
TODO


## 隔离作用域 




